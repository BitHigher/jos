Challenge 2 基于优先级的调度，详细实现在实验报告里 lab4.pdf

Question 1.
这个宏的作用就是将内核线性地址转成物理地址，因为所有的内核代码都是链接在`KERNBASE`上的线性地址空间里。在Lab1中，我们使用了一个非常简单的页表（其实也就是将链接地址减去`KERNBASE`）来将内核线性地址转化成物理地址，这种方式看似简单，其实非常冗余。因而，对于APs，JOS采用了`MPBOOTPHYS`宏来直接进行计算。对于内核线性地址va，直接将其减去`mpentry_start`，然后再加上AP的起始地址`MPENTRY_PADDR`，就得到了va的物理地址。

Question 2.
因为我们必须要考虑到一些边界情况。比如发生中断时，我们在`trap`函数中才会调用`lock_kernel`，但实际早在lock之前，程序就已经运行在内核栈了，然后我们才会把现场信息保存到栈里。如果此时共用内核栈的话，那么保存现场时就会发生错误。因为这时多CPU对内核栈的使用出现了竞争。所以即使有内核大锁，还是需要为每个CPU分配不同的内核栈。

Question 3.
因为这个e指向的是内核地址空间，而这个空间是所有进程共享的，在任何进程中，e都是指向同样的物理地址。所以即使发生了页表切换，e指向的物理地址仍然不变，所以e在前后前后都可以被正确地解引用。

详细解答可以看实验报告 lab4.pdf 里面都有写
谢谢！
